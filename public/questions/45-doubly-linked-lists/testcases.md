# Test Cases for Doubly Linked Lists

## Test Case Structure
This question uses a multi-line input format with operations for a doubly linked list.

### Input Format Pattern:
```
OPERATION_NAME [value]
OPERATION_NAME [value]
...
```

### Output Format Pattern:
```
result_1
result_2
...
```

## Test Case Categories

### Basic Test Cases (1-30): Simple Operations
- Basic insertions and deletions
- Simple print operations
- Finding elements in small lists
- Mixed operations with predictable outcomes

**Example - Test Case 1:**
**Input (`input1.txt`):**
```
INSERT_FRONT 3
INSERT_BACK 6
PRINT_FORWARD
```
**Expected Output (`expected1.txt`):**
```
3 6
```

### Edge Test Cases (31-60): Boundary Conditions
- Operations on empty lists
- Single element operations
- Deleting from empty lists
- Finding non-existent elements

**Example - Test Case 31:**
**Input (`input31.txt`):**
```
DELETE_FRONT
DELETE_BACK
PRINT_FORWARD
PRINT_BACKWARD
SIZE
```
**Expected Output (`expected31.txt`):**
```
EMPTY
EMPTY
EMPTY
EMPTY
0
```

### Performance Test Cases (61-90): Large Scale Operations
- 1000+ operations to test time complexity
- Large lists (O(n) operations should not timeout)
- Stress testing with many insertions/deletions
- Tests that would timeout with O(n²) implementations

**Example - Test Case 61:**
```
INSERT_FRONT 1
INSERT_FRONT 2
... (1000+ operations)
PRINT_FORWARD
```

### Complex Test Cases (91-120): Advanced Scenarios
- Multiple build/empty/rebuild cycles
- Alternating insert/delete patterns
- Mixed operation sequences
- State validation after complex operations

**Example - Test Case 91:**
```
INSERT_FRONT 1
INSERT_BACK 2
DELETE_FRONT
INSERT_FRONT 3
PRINT_BACKWARD
SIZE
```

### Corner Test Cases (121+): Special Values
- Zero values
- Negative numbers
- Large numbers (within constraints)
- Duplicate values

## Test Case Creation Rules

### Input Validation Rules:
1. Each line contains a valid operation
2. Operations with values have exactly one integer parameter
3. Operations without values have no parameters
4. All values are within the constraint range (-1,000,000 to 1,000,000)

### Output Format Rules:
1. Each operation that produces output gets one line
2. "EMPTY" for operations on empty lists
3. "NOT_FOUND" for unsuccessful FIND operations
4. Space-separated values for PRINT operations
5. Numeric values for SIZE and successful FIND operations

## Performance Considerations

### Time Complexity Requirements:
- INSERT_FRONT, INSERT_BACK: O(1)
- DELETE_FRONT, DELETE_BACK: O(1)
- FIND: O(n) - must traverse the list
- PRINT_FORWARD, PRINT_BACKWARD: O(n)
- SIZE: O(1) - should maintain counter

### Test Cases Designed to Fail Inefficient Solutions:
- **O(n) insertions/deletions**: Test cases with many front/back operations
- **O(n) size calculation**: Test cases with frequent SIZE operations
- **Memory leaks**: Large test cases that create/destroy many nodes

## Language-Specific Considerations

### Python Considerations:
- Use class-based approach for clean node and list management
- Handle None values carefully for empty list edge cases
- Use proper exception handling for edge cases

### Go Considerations:
- Use pointers for node references
- Careful memory management with pointer operations
- Handle nil pointer cases for empty lists

### JavaScript Considerations:
- Use object-oriented approach or functional style
- Handle undefined/null values for empty list cases
- Efficient string manipulation for output formatting

## Validation Checklist
- [ ] All 100+ test cases have valid input format
- [ ] All expected outputs generated by working solution
- [ ] Edge cases thoroughly covered (empty lists, single elements)
- [ ] Performance test cases would timeout O(n²) solutions
- [ ] Complex scenarios test multiple edge cases together
- [ ] Corner cases include special values and boundary conditions
- [ ] No test case exceeds the specified constraints
- [ ] Output format is consistent across all test cases

## Automated Test Case Generation
The test cases are generated using categories to ensure comprehensive coverage:

```python
def generate_test_case(case_num):
    if case_num <= 30:  # Basic test cases
        return generate_basic_test_case(case_num)
    elif case_num <= 60:  # Edge cases
        return generate_edge_test_case(case_num - 30)
    elif case_num <= 90:  # Performance cases
        return generate_performance_test_case(case_num - 60)
    elif case_num <= 120:  # Complex scenarios
        return generate_complex_test_case(case_num - 90)
    else:  # Corner cases
        return generate_corner_test_case(case_num - 120)
```

This ensures balanced coverage across all important scenarios while maintaining educational value and proper difficulty progression.
