# Test Cases for Pattern matching

## Test Case Structure
This question uses a 1-line input format with space-separated text and pattern.

### Input Format Pattern:
```
Line 1: text pattern
```

### Output Format Pattern:
```
true  (if text matches pattern)
false (if text does not match pattern)
```

## Test Case 1: Basic Wildcard Matching
**Input (`input.txt`):**
```
hello h*o
```
**Expected Output (`expected.txt`):**
```
true
```
**Description:** Tests basic '*' wildcard functionality where asterisk matches "ell" sequence between 'h' and 'o'.

## Test Case 2: Edge Cases and Complex Patterns
**Input (`input2.txt`):**
```
programming p?o*
```
**Expected Output (`expected2.txt`):**
```
true
```
**Description:** Tests combination of '?' (matches 'r') and '*' (matches "gramming") wildcards in a single pattern.

## Test Case 3: Performance Test - Large Input
**Input (`input3.txt`):**
```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab a*b
```
**Expected Output (`expected3.txt`):**
```
true
```
**Description:** Tests performance with long strings to ensure O(n*m) solution doesn't timeout. Poor O(2^n) recursive solutions will fail.

## Test Case Creation Rules

### Input Validation Rules:
1. Text and pattern must be separated by exactly one space
2. Text contains only lowercase English letters (a-z)
3. Pattern contains lowercase English letters, '*', and '?' only
4. Text length: 1 ≤ len(text) ≤ 1000
5. Pattern length: 1 ≤ len(pattern) ≤ 100

### Output Format Rules:
1. Output must be exactly "true" or "false" (lowercase)
2. No trailing whitespace or newlines except single trailing newline
3. No additional output or debugging information

### Comprehensive Test Scenarios:

#### Basic Matching (covers fundamental cases):
- Exact match without wildcards: "abc abc" → true
- Simple asterisk: "hello h*o" → true  
- Simple question mark: "cat c?t" → true
- No match: "dog cat" → false

#### Edge Cases (boundary conditions):
- Empty sequence with asterisk: "test t*" → true
- Question mark with single character: "a a?" → false
- Multiple asterisks: "abc a*b*c" → true
- Pattern longer than text: "hi hello" → false
- Text longer than pattern: "hello hi" → false

#### Performance Cases (large inputs):
- Long text with simple pattern: 1000 'a's + 'b' with pattern "a*b"
- Complex pattern with many wildcards on long text
- Worst-case scenarios for naive recursive approaches

#### Corner Cases (unusual but valid):
- Only wildcards: "anything *" → true
- Only question marks: "abc ???" → true
- Alternating wildcards: "test t?s*" → true
- Multiple consecutive asterisks: "hello h**o" → true

## Language-Specific Considerations

### Python Considerations:
- Use `input().strip().split()` to parse space-separated input
- Consider using `@lru_cache` for memoization if using recursion
- String slicing is efficient for subproblems
- Print "true"/"false" exactly as specified

### Go Considerations:
- Use `fmt.Scanf("%s %s", &text, &pattern)` for input parsing
- Implement 2D boolean slice for dynamic programming table
- Handle string indexing carefully (0-based)
- Use `fmt.Println("true")` or `fmt.Println("false")` for output

## Validation Checklist
- [ ] Input has exactly 2 space-separated tokens
- [ ] Text contains only lowercase letters
- [ ] Pattern contains only lowercase letters, '*', and '?'
- [ ] Output is exactly "true" or "false"
- [ ] Solution handles edge cases (empty matches, boundary conditions)
- [ ] Performance test cases timeout naive O(2^n) solutions
- [ ] All expected outputs generated by verified working solution

## Algorithm Complexity Requirements
- **Time Complexity**: O(n*m) where n=len(text), m=len(pattern)
- **Space Complexity**: O(n*m) for DP table or O(n+m) for optimized recursion
- **Timeout Threshold**: Solutions with O(2^n) complexity should timeout on performance tests

## Automated Test Case Generation
```python
def generate_test_case():
    """Generate random test cases for validation"""
    import random
    import string
    
    # Generate random text
    text_len = random.randint(1, 100)
    text = ''.join(random.choices(string.ascii_lowercase, k=text_len))
    
    # Generate pattern with wildcards
    pattern_len = random.randint(1, 20)
    pattern = []
    for _ in range(pattern_len):
        if random.random() < 0.7:  # 70% regular chars
            pattern.append(random.choice(string.ascii_lowercase))
        elif random.random() < 0.8:  # 20% asterisk
            pattern.append('*')
        else:  # 10% question mark
            pattern.append('?')
    
    return text, ''.join(pattern)

def validate_test_case(input_content, expected_content):
    """Validate test case format and correctness"""
    lines = input_content.strip().split('\n')
    if len(lines) != 1:
        return False, "Input must have exactly 1 line"
    
    parts = lines[0].split()
    if len(parts) != 2:
        return False, "Input must have exactly 2 space-separated parts"
    
    text, pattern = parts
    
    # Validate text (only lowercase letters)
    if not text.islower() or not text.isalpha():
        return False, "Text must contain only lowercase letters"
    
    # Validate pattern (lowercase letters, *, ?)
    if not all(c.islower() or c in '*?' for c in pattern):
        return False, "Pattern must contain only lowercase letters, *, and ?"
    
    # Validate expected output
    expected = expected_content.strip()
    if expected not in ["true", "false"]:
        return False, "Expected output must be 'true' or 'false'"
    
    return True, "Valid test case"
```
